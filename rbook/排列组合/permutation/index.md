

[3.6.3. 排列的生成算法(I) — C++算法编程指南 0.1 文档](https://majorli.github.io/algo_guide/ch02/sec06/263_permuting_1.html)
[3.6.4. 排列的生成算法(II) — C++算法编程指南 0.1 文档](https://majorli.github.io/algo_guide/ch02/sec06/264_permuting_2.html)


如何生成一个长度为n的序列的m的排列呢?


当然我们可以写一个如下的递归代码

按字典序列增长

很象数字的进位,但不能出现相同的数字,如果出现相同的数字那么最低的相同数字
再增加一,直到相同为止

边界判定: 形成了最大的下降序列

数字增长规则

不停的进行修复

1. 如果有相同的数字,最后一下相同数字+1
2. 如果有越界数字,则进位

重复1,2直到所有如数字符合条件

我们可以写成一个状态机,`1->2->1->2...` 直到打断
